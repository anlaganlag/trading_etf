# 最简单实现方案 - 基于数据的权重计算

## 一、核心思路

**无需复杂优化，直接用统计数据！**

```
历史数据 → 计算相关性 → 得出权重 → 立即可用
```

**原理**：
- 计算各周期涨幅与未来20天收益的**相关系数**
- 相关性高的周期 = 对未来收益预测能力强 = 应该给高权重
- 相关性低/负的周期 = 预测能力弱/反向 = 低权重或负权重

---

## 二、使用方法（3步）

### Step 1：安装依赖

```bash
pip install pandas numpy openpyxl
```

### Step 2：运行脚本

```bash
python scripts/simple_weight_calculator.py
```

**运行时间**：约1-2分钟

### Step 3：查看结果

```bash
# 查看详细报告
cat output/weight_analysis.txt
```

---

## 三、输出示例

```
================================================================================
多周期权重分析报告
================================================================================

1️⃣  相关系数分析
周期   相关系数   解释
------------------------------------------------------------
 1日    0.0234    弱正相关 ⭐
 2日    0.0456    弱正相关 ⭐
 3日   -0.0823    弱负相关（反转信号）
 4日   -0.0512    弱负相关（反转信号）
 5日    0.1123    中等正相关 ⭐⭐
...
15日    0.2567    强正相关 ⭐⭐⭐
16日    0.2689    强正相关 ⭐⭐⭐
17日    0.2734    强正相关 ⭐⭐⭐
18日    0.2801    强正相关 ⭐⭐⭐
19日    0.2856    强正相关 ⭐⭐⭐
20日    0.2912    强正相关 ⭐⭐⭐

2️⃣  推荐权重（3种方案）

方案A：归一化权重（推荐）
------------------------------------------------------------
  15日涨幅权重:    12.5
  16日涨幅权重:    13.1
  17日涨幅权重:    13.3
  18日涨幅权重:    13.6
  19日涨幅权重:    13.9
  20日涨幅权重:    14.2

  代码格式:
  periods = {15: 13, 16: 13, 17: 13, 18: 14, 19: 14, 20: 14}

方案B：排名权重（激进）
------------------------------------------------------------
  1日涨幅权重:     23
  2日涨幅权重:     45
  5日涨幅权重:     67
  ...
  20日涨幅权重:   200

方案C：阈值权重（精简）
------------------------------------------------------------
  仅保留相关系数 > 0.1 的周期
  15-20日涨幅权重各约 16-17

3️⃣  与当前策略对比

当前策略:
  1日: 30, 3日: -70, 20日: 150

推荐策略（基于数据）:
  20日: 14, 19日: 14, 18日: 14

4️⃣  关键发现

最强正相关周期（动量）:
  20日: 0.2912
  19日: 0.2856
  18日: 0.2801

负相关周期（反转信号）:
  3日: -0.0823 （短期回调可能是买入机会）
  4日: -0.0512

5️⃣  使用建议

1. 选择方案：
   - 保守：使用方案A（归一化权重）
   - 激进：使用方案B（排名权重）
   - 精简：使用方案C（阈值权重）

2. 回测验证：
   - 使用推荐权重在2023-2024年回测
   - 对比当前策略的胜率和收益

3. 实盘建议：
   - 先用小资金A/B测试
   - 观察1-2周效果
```

---

## 四、数据解读

### 相关系数含义

| 相关系数 | 含义 | 建议权重 |
|---------|------|---------|
| **> 0.2** | 强正相关（动量信号） | **高权重**（100-200） |
| **0.1 ~ 0.2** | 中等正相关 | 中等权重（50-100） |
| **0 ~ 0.1** | 弱正相关 | 低权重（0-50） |
| **-0.1 ~ 0** | 弱负相关（反转信号） | 负权重（-50~0） |
| **< -0.1** | 强负相关 | **负权重**（-100~-50） |

### 典型发现

**假设分析结果显示**：

1. **1-5日短期周期**：相关性弱/负
   - 解释：短期涨幅对未来预测能力弱，甚至可能反转
   - 建议：低权重或负权重

2. **15-20日长期周期**：相关性强（> 0.2）
   - 解释：长期动量对未来收益有很强预测能力
   - 建议：高权重（100-200）

3. **3-4日**：可能负相关
   - 解释：短期回调后容易反弹（均值回归）
   - 建议：负权重（-50~-100），逢跌买入

---

## 五、如何应用到策略

### 当前策略代码（core/signal.py 第65行）

```python
# 当前硬编码权重
periods = {1: 30, 3: -70, 20: 150}
```

### 修改为数据驱动权重

**方案1：直接替换（最简单）**

```python
# 基于数据分析的权重
periods = {15: 13, 16: 13, 17: 13, 18: 14, 19: 14, 20: 14}
```

**方案2：保留配置开关**

```python
# 在 config.py 中添加
USE_DATA_DRIVEN_WEIGHTS = True
DATA_DRIVEN_WEIGHTS = {15: 13, 16: 13, 17: 13, 18: 14, 19: 14, 20: 14}

# 在 core/signal.py 中修改
from config import config
if config.USE_DATA_DRIVEN_WEIGHTS:
    periods = config.DATA_DRIVEN_WEIGHTS
else:
    periods = {1: 30, 3: -70, 20: 150}  # 原有权重
```

---

## 六、验证步骤

### 1. 回测对比

```python
# 测试当前策略（2023年）
current_result = backtest(weights={1: 30, 3: -70, 20: 150}, year=2023)

# 测试数据驱动权重
optimized_result = backtest(weights={15: 13, 16: 13, 17: 13, 18: 14, 19: 14, 20: 14}, year=2023)

# 对比
if optimized_result['win_rate'] > current_result['win_rate']:
    print("✅ 数据驱动权重表现更好！")
```

### 2. 关键指标对比

| 指标 | 当前策略 | 数据驱动 | 改进 |
|-----|---------|---------|------|
| 胜率 | 60% | ??% | ??% |
| 超额收益 | 3.5% | ??% | ??% |
| 最大回撤 | 14% | ??% | ??% |

### 3. 决策标准

- ✅ 如果**胜率提升 ≥ 5%**：值得采用
- ✅ 如果**超额收益提升 ≥ 2%**：值得采用
- ❌ 如果**最大回撤增加 > 3%**：谨慎使用

---

## 七、真实数据 vs 模拟数据

### 当前状态

脚本目前使用**模拟数据**（如果没有掘金API）

### 如何使用真实数据

#### 方法1：使用掘金API（推荐）

脚本会自动检测掘金API，无需修改代码：

```bash
# 确保.env文件中配置了掘金Token
MY_QUANT_TGM_TOKEN=your_token_here

# 直接运行
python scripts/simple_weight_calculator.py
```

#### 方法2：使用本地数据文件

如果你已有历史数据CSV文件：

```python
# 修改 load_historical_data 函数
def load_historical_data(symbols, start_date, end_date):
    # 从CSV加载
    df = pd.read_csv('data/历史价格.csv', index_col=0, parse_dates=True)
    return df
```

#### 方法3：从现有系统获取

如果你的 `context.prices_df` 已有数据：

```python
# 在主程序中调用
from main import context

# 使用现有数据
prices_df = context.prices_df
returns_dict = calculate_period_returns(prices_df)
# ...
```

---

## 八、优势对比

### 这个方案 vs 复杂优化方案

| 维度 | 简单统计方案 | 贝叶斯优化 | AI模型 |
|-----|------------|-----------|--------|
| **实施时间** | 5分钟 | 7天 | 11周 |
| **需要技能** | 基础统计 | 优化算法 | 机器学习 |
| **代码行数** | 200行 | 500行 | 2000行 |
| **可解释性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **维护成本** | 极低 | 中 | 高 |
| **数据支撑** | ✅ 直接相关性 | ✅ 回测优化 | ✅ 模型训练 |

---

## 九、常见问题

### Q1：为什么不用复杂的优化算法？

**答**：相关性分析已经能告诉我们哪些周期重要。复杂算法可能过拟合，反而不如简单方法稳定。

### Q2：相关系数会不会变化？

**答**：会。建议每季度重新计算一次权重，适应市场变化。

### Q3：如果所有周期相关性都很低怎么办？

**答**：说明单纯的动量策略可能不适合当前市场。考虑：
- 加入其他因子（波动率、成交量等）
- 调整持有周期
- 等待市场风格转换

### Q4：负相关的周期真的要用负权重吗？

**答**：是的！负相关意味着"逢跌买入"策略有效。这就是你当前策略中 `3日: -70` 的逻辑。

---

## 十、下一步行动

### 立即可做（5分钟）

```bash
# 1. 运行脚本
python scripts/simple_weight_calculator.py

# 2. 查看报告
cat output/weight_analysis.txt

# 3. 记录推荐权重
# 例如：{15: 13, 16: 13, 17: 13, 18: 14, 19: 14, 20: 14}
```

### 今天完成（1小时）

1. 使用真实数据（而非模拟数据）
2. 对比分析报告中的3种权重方案
3. 选择一种方案准备回测

### 本周完成（2-3天）

1. 回测验证：2023-2024年数据
2. 对比当前策略
3. 如果效果好，准备实盘A/B测试

---

## 十一、预期效果

### 如果数据显示长期动量强（15-20日相关性高）

**推荐权重**：
```python
periods = {
    15: 50,
    16: 60,
    17: 70,
    18: 80,
    19: 90,
    20: 100
}
```

**预期效果**：
- 胜率：65-70%
- 更稳定的长期收益
- 减少短期波动干扰

### 如果数据显示短期反转明显（3-5日负相关）

**推荐权重**：
```python
periods = {
    3: -80,
    4: -50,
    5: -30,
    20: 150
}
```

**预期效果**：
- 捕捉短期回调买入机会
- 长期动量跟随

---

**文档版本**：v1.0
**创建日期**：2024-02-07
**适用人群**：所有人（无需技术背景）
**预计耗时**：5分钟运行 + 10分钟阅读报告
