# 多周期权重参数优化方案

## 一、核心思路

**目标**：通过历史回测，找到1-20天各周期涨幅的最佳权重组合

**方法**：参数搜索 + 回测验证（无需复杂AI模型）

**优势**：简单、透明、可解释、易实施

---

## 二、问题定义

### 2.1 当前状态
```python
# 现有固定权重
weights = {
    1: 30,    # 1日涨幅
    3: -70,   # 3日涨幅（反转因子）
    20: 150   # 20日涨幅
}
# 其他周期权重为0
```

### 2.2 待优化目标
找到最优的20个权重参数：
```python
optimal_weights = {
    1: w1,
    2: w2,
    3: w3,
    ...
    20: w20
}
```

使得选出的股票在未来20天满足：
1. **胜率** ≥ 70%（跑赢指数的概率）
2. **平均超额收益** ≥ 5%
3. **最大回撤** ≤ 15%

---

## 三、优化方案对比

### 方案A：网格搜索（Grid Search）

**原理**：暴力遍历所有可能的权重组合

**适用场景**：参数空间较小（≤5个参数）

**优点**：
- 简单直接，保证找到全局最优
- 结果可重现

**缺点**：
- 计算量大（20个参数 × 每个10种取值 = 10^20 种组合）
- 不现实

**实施建议**：
只优化核心周期（如1,3,5,10,20天），其他设为0

```python
# 简化搜索空间
core_periods = [1, 3, 5, 10, 20]
weight_range = [-200, -100, -50, 0, 50, 100, 150, 200]

# 组合数：8^5 = 32,768（可行）
```

---

### 方案B：贝叶斯优化（Bayesian Optimization）⭐ **推荐**

**原理**：基于高斯过程建模，智能采样参数空间

**适用场景**：任意维度参数优化

**优点**：
- 样本效率高（仅需100-500次试验）
- 可处理20维参数空间
- 自动平衡探索与利用

**缺点**：
- 实现略复杂（但有成熟库如Optuna）

**实施建议**：
使用Optuna库，全自动优化

```python
import optuna

def objective(trial):
    # 定义权重搜索空间
    weights = {
        i: trial.suggest_float(f'w_{i}', -200, 200)
        for i in range(1, 21)
    }

    # 回测计算收益
    result = backtest(weights)

    # 多目标优化
    win_rate = result['win_rate']
    excess_return = result['excess_return']

    # 惩罚不满足约束的方案
    if win_rate < 0.70:
        return -1000

    return excess_return  # 最大化超额收益

# 运行优化
study = optuna.create_study(direction='maximize')
study.optimize(objective, n_trials=200)
```

---

### 方案C：遗传算法（Genetic Algorithm）

**原理**：模拟生物进化，迭代优化权重组合

**适用场景**：复杂的非凸优化问题

**优点**：
- 不易陷入局部最优
- 可处理离散+连续参数

**缺点**：
- 收敛速度慢
- 需要手动调节超参数（种群大小、变异率等）

**实施建议**：
作为备选方案，与贝叶斯优化对比

```python
from deap import algorithms, base, creator, tools

# 定义个体（20个权重）
creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", list, fitness=creator.FitnessMax)

# 评估函数
def evaluate(individual):
    weights = {i+1: w for i, w in enumerate(individual)}
    result = backtest(weights)

    if result['win_rate'] < 0.70:
        return (-1000,)

    return (result['excess_return'],)

# 运行遗传算法
pop = toolbox.population(n=50)
algorithms.eaSimple(pop, toolbox, cxpb=0.5, mutpb=0.2, ngen=100)
```

---

## 四、推荐实施路径

### 阶段1：快速验证（1-2天）

**目标**：验证思路可行性

**方法**：简化网格搜索

```python
# 只优化3个核心周期
periods = [1, 5, 20]
weights_range = [-100, -50, 0, 50, 100, 150, 200]

best_score = -inf
best_weights = None

for w1 in weights_range:
    for w5 in weights_range:
        for w20 in weights_range:
            weights = {1: w1, 5: w5, 20: w20}
            result = backtest_2023(weights)  # 仅用2023年数据

            if result['win_rate'] >= 0.70 and result['excess_return'] > best_score:
                best_score = result['excess_return']
                best_weights = weights

print(f"Best weights: {best_weights}")
print(f"Win rate: {result['win_rate']:.2%}")
print(f"Excess return: {best_score:.2%}")
```

**预期结果**：
- 运行时间：< 2小时（7^3 = 343次回测）
- 得到初步最优权重组合
- 验证是否能达到胜率70%

---

### 阶段2：全面优化（3-5天）

**目标**：找到20维最优权重

**方法**：贝叶斯优化（Optuna）

**完整代码框架**：

```python
import optuna
import pandas as pd
from core.strategy import run_backtest

def objective(trial):
    """
    优化目标函数

    Args:
        trial: Optuna trial对象

    Returns:
        综合得分（考虑胜率约束）
    """
    # 1. 生成权重参数
    weights = {}
    for period in range(1, 21):
        weights[period] = trial.suggest_float(
            f'weight_{period}',
            -200, 200,
            step=10  # 步长10，减少搜索空间
        )

    # 2. 运行回测（2020-2023）
    result = run_backtest(
        weights=weights,
        start_date='2020-01-01',
        end_date='2023-12-31',
        top_n=4,
        rebalance_period=10
    )

    # 3. 提取指标
    win_rate = result['metrics']['win_rate']
    excess_return = result['metrics']['excess_return']
    max_drawdown = result['metrics']['max_drawdown']
    sharpe_ratio = result['metrics']['sharpe_ratio']

    # 4. 多目标优化（转为单目标）
    # 硬约束
    if win_rate < 0.70:
        return -1000
    if max_drawdown > 0.15:
        return -500

    # 优化目标：综合得分
    score = (
        excess_return * 100 +          # 超额收益（主要目标）
        (win_rate - 0.70) * 50 +       # 超过70%的胜率奖励
        sharpe_ratio * 5 -             # 夏普比率奖励
        max_drawdown * 50              # 回撤惩罚
    )

    return score

# 创建优化任务
study = optuna.create_study(
    study_name='multi_period_weight_optimization',
    direction='maximize',
    sampler=optuna.samplers.TPESampler(seed=42),  # 贝叶斯优化
    pruner=optuna.pruners.MedianPruner()  # 提前剪枝差的试验
)

# 运行优化（200次试验）
study.optimize(
    objective,
    n_trials=200,
    timeout=3600*8,  # 最多8小时
    n_jobs=4  # 并行4个进程
)

# 输出最优结果
print("=" * 60)
print("最优权重参数:")
print("=" * 60)
for key, value in study.best_params.items():
    period = int(key.split('_')[1])
    print(f"  {period}日涨幅权重: {value:>6.1f}")

print("\n" + "=" * 60)
print("性能指标:")
print("=" * 60)
best_weights = {
    int(k.split('_')[1]): v
    for k, v in study.best_params.items()
}
final_result = run_backtest(best_weights, '2020-01-01', '2023-12-31')
print(f"  胜率: {final_result['metrics']['win_rate']:.2%}")
print(f"  超额收益: {final_result['metrics']['excess_return']:.2%}")
print(f"  最大回撤: {final_result['metrics']['max_drawdown']:.2%}")
print(f"  夏普比率: {final_result['metrics']['sharpe_ratio']:.2f}")

# 保存结果
study.trials_dataframe().to_csv('output/optimization_history.csv')
```

---

### 阶段3：验证与测试（2-3天）

**1. 训练集/测试集分离验证**

```python
# 训练集：2020-2022
train_result = run_backtest(best_weights, '2020-01-01', '2022-12-31')

# 测试集：2023-2024
test_result = run_backtest(best_weights, '2023-01-01', '2024-12-31')

# 对比分析
comparison = pd.DataFrame({
    'Train': [
        train_result['metrics']['win_rate'],
        train_result['metrics']['excess_return'],
        train_result['metrics']['max_drawdown']
    ],
    'Test': [
        test_result['metrics']['win_rate'],
        test_result['metrics']['excess_return'],
        test_result['metrics']['max_drawdown']
    ]
}, index=['Win Rate', 'Excess Return', 'Max Drawdown'])

print(comparison)

# 判断是否过拟合
if test_result['metrics']['win_rate'] < train_result['metrics']['win_rate'] * 0.9:
    print("⚠️ 警告：可能存在过拟合！")
```

**2. 滚动窗口验证**

```python
# 每6个月重新优化一次，测试稳定性
rolling_results = []

for year in [2020, 2021, 2022, 2023]:
    for half in [1, 2]:
        # 训练期：过去12个月
        train_start = f'{year-1}-{1 if half==1 else 7:02d}-01'
        train_end = f'{year}-{6 if half==1 else 12:02d}-30'

        # 测试期：未来6个月
        test_start = f'{year}-{7 if half==1 else 1:02d}-01'
        test_end = f'{year if half==1 else year+1}-{12 if half==1 else 6:02d}-30'

        # 重新优化
        study_temp = optuna.create_study(direction='maximize')
        study_temp.optimize(
            lambda trial: objective_with_dates(trial, train_start, train_end),
            n_trials=100
        )

        # 测试集验证
        test_result = run_backtest(
            study_temp.best_params,
            test_start,
            test_end
        )

        rolling_results.append({
            'period': f'{year}H{half}',
            'win_rate': test_result['metrics']['win_rate'],
            'excess_return': test_result['metrics']['excess_return']
        })

# 可视化
import matplotlib.pyplot as plt
df = pd.DataFrame(rolling_results)
df.plot(x='period', y=['win_rate', 'excess_return'], kind='bar')
plt.savefig('output/rolling_validation.png')
```

**3. 与当前策略对比**

```python
# 当前策略
current_weights = {1: 30, 3: -70, 20: 150}
current_result = run_backtest(current_weights, '2023-01-01', '2024-12-31')

# 优化策略
optimal_result = run_backtest(best_weights, '2023-01-01', '2024-12-31')

# 对比表
comparison_df = pd.DataFrame({
    '当前策略': [
        current_result['metrics']['win_rate'],
        current_result['metrics']['excess_return'],
        current_result['metrics']['sharpe_ratio'],
        current_result['metrics']['max_drawdown']
    ],
    '优化策略': [
        optimal_result['metrics']['win_rate'],
        optimal_result['metrics']['excess_return'],
        optimal_result['metrics']['sharpe_ratio'],
        optimal_result['metrics']['max_drawdown']
    ],
    '改进幅度': [
        (optimal_result['metrics']['win_rate'] / current_result['metrics']['win_rate'] - 1) * 100,
        (optimal_result['metrics']['excess_return'] - current_result['metrics']['excess_return']) * 100,
        (optimal_result['metrics']['sharpe_ratio'] / current_result['metrics']['sharpe_ratio'] - 1) * 100,
        (optimal_result['metrics']['max_drawdown'] / current_result['metrics']['max_drawdown'] - 1) * 100
    ]
}, index=['胜率', '超额收益', '夏普比率', '最大回撤'])

print(comparison_df)
```

---

## 五、代码实现框架

### 5.1 目录结构

```
project/
├── optimization/
│   ├── __init__.py
│   ├── optimizer.py          # 优化器主类
│   ├── objective.py          # 目标函数定义
│   └── validators.py         # 验证工具
├── scripts/
│   ├── run_optimization.py   # 运行优化脚本
│   ├── validate_results.py   # 验证脚本
│   └── compare_strategies.py # 策略对比脚本
└── output/
    ├── best_weights.json     # 最优权重
    └── optimization_log.txt  # 优化日志
```

### 5.2 核心代码

**optimization/optimizer.py**

```python
import optuna
import json
from pathlib import Path
from typing import Dict, Callable
from config import logger

class WeightOptimizer:
    """
    多周期权重参数优化器
    """

    def __init__(
        self,
        backtest_func: Callable,
        n_periods: int = 20,
        weight_range: tuple = (-200, 200),
        weight_step: float = 10
    ):
        """
        初始化优化器

        Args:
            backtest_func: 回测函数，签名为 func(weights, start, end) -> dict
            n_periods: 周期数量（1-20天）
            weight_range: 权重搜索范围
            weight_step: 权重步长
        """
        self.backtest_func = backtest_func
        self.n_periods = n_periods
        self.weight_range = weight_range
        self.weight_step = weight_step
        self.study = None

    def objective(self, trial: optuna.Trial, start_date: str, end_date: str) -> float:
        """
        优化目标函数
        """
        # 生成权重参数
        weights = {}
        for period in range(1, self.n_periods + 1):
            weights[period] = trial.suggest_float(
                f'weight_{period}',
                self.weight_range[0],
                self.weight_range[1],
                step=self.weight_step
            )

        # 运行回测
        try:
            result = self.backtest_func(weights, start_date, end_date)
            metrics = result['metrics']
        except Exception as e:
            logger.error(f"Backtest failed: {e}")
            return -10000

        # 提取指标
        win_rate = metrics.get('win_rate', 0)
        excess_return = metrics.get('excess_return', 0)
        max_drawdown = metrics.get('max_drawdown', 1)
        sharpe_ratio = metrics.get('sharpe_ratio', 0)

        # 硬约束检查
        if win_rate < 0.70:
            return -1000 - (0.70 - win_rate) * 1000

        if max_drawdown > 0.15:
            return -500 - (max_drawdown - 0.15) * 500

        # 综合得分
        score = (
            excess_return * 100 +
            (win_rate - 0.70) * 50 +
            sharpe_ratio * 5 -
            max_drawdown * 30
        )

        return score

    def optimize(
        self,
        n_trials: int = 200,
        start_date: str = '2020-01-01',
        end_date: str = '2023-12-31',
        n_jobs: int = 1,
        timeout: int = None
    ) -> Dict:
        """
        运行优化

        Args:
            n_trials: 试验次数
            start_date: 回测起始日期
            end_date: 回测结束日期
            n_jobs: 并行进程数
            timeout: 超时时间（秒）

        Returns:
            最优权重字典
        """
        logger.info(f"Starting optimization with {n_trials} trials...")

        # 创建研究
        self.study = optuna.create_study(
            study_name=f'weight_opt_{start_date}_{end_date}',
            direction='maximize',
            sampler=optuna.samplers.TPESampler(seed=42),
            pruner=optuna.pruners.MedianPruner(
                n_startup_trials=10,
                n_warmup_steps=5
            )
        )

        # 运行优化
        self.study.optimize(
            lambda trial: self.objective(trial, start_date, end_date),
            n_trials=n_trials,
            n_jobs=n_jobs,
            timeout=timeout,
            show_progress_bar=True
        )

        # 提取最优权重
        best_weights = self._extract_weights(self.study.best_params)

        logger.info(f"Optimization completed!")
        logger.info(f"Best score: {self.study.best_value:.2f}")
        logger.info(f"Best weights: {best_weights}")

        return best_weights

    def _extract_weights(self, params: Dict) -> Dict[int, float]:
        """从Optuna参数中提取权重"""
        weights = {}
        for key, value in params.items():
            if key.startswith('weight_'):
                period = int(key.split('_')[1])
                weights[period] = round(value, 1)
        return weights

    def save_results(self, output_path: str = 'output/best_weights.json'):
        """保存优化结果"""
        if self.study is None:
            raise ValueError("No optimization has been run yet!")

        best_weights = self._extract_weights(self.study.best_params)

        result = {
            'best_weights': best_weights,
            'best_score': self.study.best_value,
            'n_trials': len(self.study.trials),
            'optimization_history': [
                {
                    'trial': i,
                    'score': trial.value,
                    'weights': self._extract_weights(trial.params)
                }
                for i, trial in enumerate(self.study.trials)
                if trial.value is not None
            ]
        }

        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2, ensure_ascii=False)

        logger.info(f"Results saved to {output_path}")

    def plot_optimization_history(self, output_path: str = 'output/optimization_history.png'):
        """绘制优化历史"""
        if self.study is None:
            raise ValueError("No optimization has been run yet!")

        import matplotlib.pyplot as plt

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

        # 优化历史
        optuna.visualization.matplotlib.plot_optimization_history(self.study, ax=ax1)

        # 参数重要性
        optuna.visualization.matplotlib.plot_param_importances(self.study, ax=ax2)

        plt.tight_layout()
        plt.savefig(output_path, dpi=150)
        logger.info(f"Plot saved to {output_path}")
```

**scripts/run_optimization.py**

```python
"""
运行权重参数优化

使用方法：
    python scripts/run_optimization.py --trials 200 --jobs 4
"""
import argparse
from optimization.optimizer import WeightOptimizer
from core.strategy import run_backtest_with_weights
from config import logger

def main():
    parser = argparse.ArgumentParser(description='Optimize multi-period weights')
    parser.add_argument('--trials', type=int, default=200, help='Number of trials')
    parser.add_argument('--jobs', type=int, default=1, help='Number of parallel jobs')
    parser.add_argument('--start', type=str, default='2020-01-01', help='Start date')
    parser.add_argument('--end', type=str, default='2023-12-31', help='End date')
    parser.add_argument('--timeout', type=int, default=None, help='Timeout in seconds')
    args = parser.parse_args()

    logger.info("=" * 60)
    logger.info("多周期权重参数优化")
    logger.info("=" * 60)
    logger.info(f"试验次数: {args.trials}")
    logger.info(f"并行进程: {args.jobs}")
    logger.info(f"回测区间: {args.start} ~ {args.end}")

    # 创建优化器
    optimizer = WeightOptimizer(
        backtest_func=run_backtest_with_weights,
        n_periods=20,
        weight_range=(-200, 200),
        weight_step=10
    )

    # 运行优化
    best_weights = optimizer.optimize(
        n_trials=args.trials,
        start_date=args.start,
        end_date=args.end,
        n_jobs=args.jobs,
        timeout=args.timeout
    )

    # 保存结果
    optimizer.save_results('output/best_weights.json')
    optimizer.plot_optimization_history('output/optimization_history.png')

    # 打印最优权重
    logger.info("\n" + "=" * 60)
    logger.info("最优权重参数:")
    logger.info("=" * 60)
    for period in sorted(best_weights.keys()):
        weight = best_weights[period]
        if abs(weight) > 5:  # 只显示非零权重
            logger.info(f"  {period:2d}日涨幅: {weight:>7.1f}")

    logger.info("\n优化完成！")

if __name__ == '__main__':
    main()
```

---

## 六、预期结果

### 6.1 可能的权重分布

基于动量与反转理论，预测最优权重可能呈现：

```python
# 预期模式（仅示例，实际以优化结果为准）
expected_pattern = {
    1:  20,    # 短期爆发（小正权重）
    2:  10,
    3: -50,    # 短期反转（负权重）
    4: -30,
    5:  0,
    6:  10,
    7:  20,
    8:  30,
    9:  40,
    10: 60,    # 中期动量（中等正权重）
    11: 70,
    12: 80,
    13: 90,
    14: 100,
    15: 120,   # 长期动量（大正权重）
    16: 130,
    17: 140,
    18: 150,
    19: 160,
    20: 180    # 最长周期（最大权重）
}
```

**解释**：
- **1-2日**：小正权重（捕捉即时爆发）
- **3-4日**：负权重（短期反转，逢回调买入）
- **10-20日**：递增正权重（长期动量越强，权重越大）

### 6.2 性能提升预期

| 指标 | 当前策略 | 优化后 | 改进 |
|-----|---------|--------|------|
| **胜率** | 60% | 72% | +20% |
| **超额收益** | 3.5% | 6.2% | +77% |
| **夏普比率** | 1.2 | 1.9 | +58% |
| **最大回撤** | 14% | 11% | -21% |

---

## 七、实施时间表

| 阶段 | 任务 | 工作量 | 输出 |
|-----|------|--------|------|
| **Day 1** | 实现优化器框架 | 4小时 | `optimizer.py` |
| **Day 2** | 集成回测函数 | 3小时 | 可运行的优化脚本 |
| **Day 3** | 运行首次优化（100次试验） | 6小时 | 初步最优权重 |
| **Day 4** | 扩大搜索（200次试验） | 8小时 | 精细最优权重 |
| **Day 5** | 验证测试（训练/测试集分离） | 4小时 | 验证报告 |
| **Day 6** | 对比当前策略 | 2小时 | 对比分析报告 |
| **Day 7** | 集成到生产系统 | 3小时 | 上线配置 |

**总计**：7天（约1周）

---

## 八、风险与应对

| 风险 | 概率 | 影响 | 应对措施 |
|-----|------|------|---------|
| **优化结果过拟合** | 高 | 严重 | 1. 训练/测试集严格分离<br>2. 滚动窗口验证<br>3. 限制权重范围（-200~200） |
| **计算时间过长** | 中 | 中 | 1. 使用并行计算<br>2. 减少试验次数（100次够用）<br>3. 提前剪枝差的试验 |
| **无法满足约束** | 低 | 中 | 1. 放宽约束（胜率65%）<br>2. 调整目标函数权重<br>3. 增加训练数据 |
| **实盘效果差** | 中 | 高 | 1. A/B测试小资金验证<br>2. 定期重新优化（每季度）<br>3. 保留人工调整接口 |

---

## 九、快速启动

### 安装依赖
```bash
pip install optuna pandas matplotlib
```

### 运行优化
```bash
# 快速测试（10次试验）
python scripts/run_optimization.py --trials 10 --start 2023-01-01 --end 2023-12-31

# 完整优化（200次试验，4并行）
python scripts/run_optimization.py --trials 200 --jobs 4
```

### 查看结果
```bash
# 查看最优权重
cat output/best_weights.json

# 查看优化历史图
open output/optimization_history.png
```

---

## 十、后续扩展

### 1. 动态权重
根据市场状态（牛市/熊市）使用不同权重组合

```python
market_weights = {
    'bull': optimize_for_bull_market(),
    'bear': optimize_for_bear_market(),
    'neutral': optimize_for_neutral_market()
}

# 实盘根据市场状态切换
current_market = detect_market_regime()
weights = market_weights[current_market]
```

### 2. 多目标优化
同时优化胜率、收益、回撤等多个指标

```python
# Pareto前沿
study = optuna.create_study(
    directions=['maximize', 'maximize', 'minimize']  # [胜率, 收益, 回撤]
)
```

### 3. 自适应重优化
当实盘表现下降时自动触发重新优化

```python
if live_win_rate < backtest_win_rate * 0.8:
    logger.warning("Performance degradation detected! Re-optimizing...")
    new_weights = optimizer.optimize(recent_data)
    update_weights(new_weights)
```

---

**文档版本**：v1.0
**创建日期**：2024-02-07
**更新日期**：2024-02-07
**适用范围**：参数优化、历史回测验证
