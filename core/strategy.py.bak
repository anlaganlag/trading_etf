"""
ç­–ç•¥æ ¸å¿ƒæ¨¡å—
- algo: ä¸»è°ƒä»“é€»è¾‘
- on_bar: ç›˜ä¸­æ­¢æŸç›‘æ§
- on_backtest_finished: å›æµ‹ç»“æŸæŠ¥å‘Š
"""
import pandas as pd
from gm.api import (
    MODE_BACKTEST, MODE_LIVE, current,
    order_volume, order_target_volume, order_target_percent,
    OrderSide_Sell, OrderType_Market,
    PositionEffect_Close, PositionSide_Long
)
from config import config, logger
from .signal import get_market_regime, get_ranking


def algo(context):
    """ä¸»è°ƒä»“é€»è¾‘ - æ¯æ—¥å®šæ—¶æ‰§è¡Œ"""
    current_dt = context.now.replace(tzinfo=None)
    logger.info(f"--- ğŸ Algo Triggered at {current_dt} ---")

    # === é£æ§å‰ç½®æ£€æŸ¥ (ä»…å®ç›˜) ===
    if context.mode == MODE_LIVE:
        context.risk_safe.on_day_start(context)
        if not context.risk_safe.check_daily_loss(context):
            logger.warning(f"ğŸ§¨ [ALGO] è§¦å‘æ¯æ—¥äºæŸç†”æ–­ï¼Œä»Šæ—¥è·³è¿‡äº¤æ˜“")
            return

    # æ³¨å…¥å®æ—¶è¡Œæƒ… (Live)
    if context.mode == MODE_LIVE:
        logger.debug("ğŸ’‰ Injecting realtime ticks into prices_df...")
        ticks = current(symbols=list(context.whitelist))
        td = {t['symbol']: t['price'] for t in ticks if t['price'] > 0}
        if td:
            rows = pd.DataFrame(
                [td], 
                index=[current_dt.replace(hour=0, minute=0, second=0, microsecond=0)]
            )
            context.prices_df = pd.concat([
                context.prices_df[~context.prices_df.index.isin(rows.index)], 
                rows
            ]).sort_index()

    context.rpm.days_count += 1
    if not context.rpm.initialized:
        logger.info("ğŸ†• Initializing Portfolio Manager...")
        acc = (context.account(account_id=context.account_id) 
               if context.mode == MODE_LIVE else context.account())
        if acc:
            context.rpm.initialize_tranches(acc.cash.nav)
            logger.info(f"ğŸ’° Initialized {config.REBALANCE_PERIOD_T} tranches with NAV: {acc.cash.nav:,.2f}")
        else:
            logger.error("âŒ Failed to get account info for initialization")
            return
    # === ğŸ›¡ï¸ å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿ä»·æ ¼æ•°æ®åˆ‡ç‰‡æ­£ç¡® ===
    prices_slice = context.prices_df[context.prices_df.index <= current_dt]

    # 1. æ›´æ–°ä»·å€¼ä¸æ­¢æŸ
    if prices_slice.empty:
        logger.warning(f"âš ï¸ [ALGO] No price data available up to {current_dt}")
        return
    
    price_map = prices_slice.iloc[-1].to_dict()
    for t in context.rpm.tranches:
        t.update_value(price_map)
        to_sell = t.check_guard(price_map, current_dt)
        if to_sell:
            t.guard_triggered_today = True
            logger.warning(f"ğŸ›¡ï¸ [Tranche {t.id}] Guard Triggered! Selling: {to_sell}")
            for s in to_sell:
                t.sell(s, price_map.get(s, 0))
        else:
            t.guard_triggered_today = False

    # 2. è½®åŠ¨è°ƒä»“ (Soft Rotation)
    active_idx = (context.rpm.days_count - 1) % config.REBALANCE_PERIOD_T
    active_t = context.rpm.tranches[active_idx]
    logger.info(f"ğŸ”„ Processing Tranche Index: {active_idx} (Day {context.rpm.days_count})")

    rank_df, _ = get_ranking(context, current_dt)
    
    if rank_df is not None and not active_t.guard_triggered_today:
        current_top_n = config.TOP_N
        # A. ç”Ÿæˆç›®æ ‡å€™é€‰åå• (Top N + Buffer)
        candidates = []
        themes = {}
        for code, row in rank_df.iterrows():
            if themes.get(row['theme'], 0) < config.MAX_PER_THEME:
                candidates.append(code)
                themes[row['theme']] = themes.get(row['theme'], 0) + 1
        
        core_targets = candidates[:current_top_n]
        buffer_targets = candidates[:current_top_n + config.TURNOVER_BUFFER]
        
        # B. æ™ºèƒ½ä¿ç•™é€»è¾‘ (Soft Rotation)
        existing_holdings = list(active_t.holdings.keys())
        kept_holdings, targets_to_buy = [], []
        current_slots_used = 0
        
        for s in existing_holdings:
            if s in buffer_targets and current_slots_used < current_top_n:
                kept_holdings.append(s)
                current_slots_used += 1
                logger.info(f"ğŸ¤ [Tranche {active_idx}] Kept in Buffer: {s}")
            else:
                active_t.sell(s, price_map.get(s, 0))
                logger.info(f"ğŸ’¨ [Tranche {active_idx}] Dropped from Buffer: {s}")
        
        # C. å¡«å……æ–°æ ‡çš„
        for s in core_targets:
            if current_slots_used >= current_top_n:
                break
            if s not in kept_holdings:
                targets_to_buy.append(s)
                current_slots_used += 1

        # D. æ‰§è¡Œé…ç½®ä¸ä¹°å…¥
        scale = (get_market_regime(context, current_dt) if config.DYNAMIC_POSITION else 1.0) * \
                (context.risk_scaler if config.ENABLE_META_GATE else 1.0)
        
        logger.info(f"ğŸš¦ Market State: {context.market_state} | Scale: {scale:.2%}")

        final_list = kept_holdings + targets_to_buy
        weights = {
            s: 1.0
            for i, s in enumerate(candidates) if s in final_list
        }
        total_w = sum(weights.values())
        
        if total_w > 0:
            unit_val = (active_t.total_value * 0.99 * scale) / total_w
            for s in final_list:
                target_val = unit_val * weights[s]
                current_val = active_t.holdings.get(s, 0) * price_map.get(s, 0)
                diff_val = target_val - current_val

                if diff_val > 0:
                    vol = None
                    if config.DYNAMIC_STOP_LOSS:
                        hist = context.prices_df[context.prices_df.index <= current_dt]
                        if s in hist.columns and len(hist) > config.ATR_LOOKBACK:
                            daily_rets = hist[s].pct_change().dropna()
                            if len(daily_rets) >= config.ATR_LOOKBACK:
                                vol = daily_rets.tail(config.ATR_LOOKBACK).std()
                    active_t.buy(s, diff_val, price_map.get(s, 0), current_dt, vol)
                    logger.info(f"ğŸ›’ [Tranche {active_idx}] Buying {s} | Target Val: {target_val:,.0f}")
                elif diff_val < -100:
                    if abs(diff_val) > target_val * 0.2:
                        qty = int(abs(diff_val) / price_map.get(s, 1) / 100) * 100
                        if qty > 0:
                            active_t.sell_qty(s, qty, price_map.get(s, 0))
    else:
        logger.warning(f"âš ï¸ [ALGO] Ranking failed or guard triggered today. Tranche {active_idx} liquidation.")
        for s in list(active_t.holdings.keys()):
            active_t.sell(s, price_map.get(s, 0))

    # 3. æœ€ç»ˆåŒæ­¥ (Order Execution)
    tgt_qty = context.rpm.total_holdings
    acc = (context.account(account_id=context.account_id) 
           if context.mode == MODE_LIVE else context.account())
    
    if not acc:
        logger.error("âŒ Failed to sync: Account object is None")
        return

    # A. å–å‡ºå¤šä½™æŒä»“
    for pos in acc.positions():
        diff = pos.amount - tgt_qty.get(pos.symbol, 0)
        if diff > 0 and pos.available > 0:
            order_volume(
                symbol=pos.symbol,
                volume=int(min(diff, pos.available)),
                side=OrderSide_Sell,
                order_type=OrderType_Market,
                position_effect=PositionEffect_Close
            )

    # B. ä¹°å…¥ç›®æ ‡ä»“ä½
    for sym, qty in tgt_qty.items():
        if qty > 0:
            order_target_volume(
                symbol=sym,
                volume=int(qty),
                position_side=PositionSide_Long,
                order_type=OrderType_Market
            )

    context.rpm.save_state()

    # === æ¯æ—¥æ”¶ç›˜æ±‡æŠ¥ (ä»…å®ç›˜) ===
    if context.mode == MODE_LIVE:
        logger.info("ğŸ“¤ Algorithm finished. Triggering notifications...")
        context.mailer.send_report(context)
        context.wechat.send_report(context)


def on_bar(context, bars):
    """ç›˜ä¸­é«˜é¢‘æ­¢æŸç›‘æ§"""
    if context.mode == MODE_BACKTEST:
        return
    
    bar_dt = context.now.replace(tzinfo=None)
    for bar in bars:
        for t in context.rpm.tranches:
            if bar.symbol in t.holdings:
                rec = t.pos_records.get(bar.symbol)
                if not rec:
                    continue

                # ä¿æŠ¤æœŸæ£€æŸ¥
                entry_dt = rec.get('entry_dt')
                if entry_dt and config.PROTECTION_DAYS > 0:
                    days_held = (bar_dt - entry_dt).days
                    if days_held <= config.PROTECTION_DAYS:
                        continue

                rec['high_price'] = max(rec['high_price'], bar.high)
                entry, high, curr = rec['entry_price'], rec['high_price'], bar.close
                
                is_stop = (
                    curr < entry * (1 - config.STOP_LOSS) or
                    (high > entry * (1 + config.TRAILING_TRIGGER) and 
                     curr < high * (1 - config.TRAILING_DROP))
                )
                
                if is_stop:
                    logger.warning(f"âš¡ [on_bar] Guard Trigger for {bar.symbol}! Liquidating.")
                    order_target_percent(
                        symbol=bar.symbol,
                        percent=0,
                        position_side=PositionSide_Long,
                        order_type=OrderType_Market
                    )
                    t.sell(bar.symbol, curr)
                    context.rpm.save_state()


def on_backtest_finished(context, indicator):
    """å›æµ‹ç»“æŸæŠ¥å‘Š"""
    dsl_status = (
        f"ATR*{config.ATR_MULTIPLIER}" if config.DYNAMIC_STOP_LOSS 
        else f"Fixed {config.STOP_LOSS*100:.0f}%"
    )
    dtn_status = "Dynamic" if config.DYNAMIC_TOP_N else f"Fixed {config.TOP_N}"
    
    logger.info("=" * 60)
    logger.info(f"ğŸ“Š BACKTEST REPORT (BUFFER={config.TURNOVER_BUFFER}, SL={dsl_status}, TOP_N={dtn_status})")
    logger.info(f"ğŸš€ Return: {indicator.get('pnl_ratio', 0)*100:.2f}%")
    logger.info(f"ğŸ“‰ MaxDD: {indicator.get('max_drawdown', 0)*100:.2f}%")
    logger.info(f"ğŸ’ Sharpe: {indicator.get('sharp_ratio', 0):.2f}")
    logger.info("=" * 60)
